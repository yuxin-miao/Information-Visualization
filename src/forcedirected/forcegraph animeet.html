<!DOCTYPE html>
<html>
    
<head>
    <title>Force</title>
    <script src="//d3js.org/d3.v7.min.js"></script>
</head>

<body style="background-color:#010033;">
    <svg width="1800" height="920" id="mainsvg" class="svgs"></svg>
    <script>

        let svg = d3.select('#mainsvg');
        var width = svg.attr('width'),
            height = svg.attr('height');
        let nodes, links;
        let circles, lines, text, elementGroup;
        let simulation;

        nodes = [
        {"name": "Attack on Titan The Final Season: Part II","type":"main"},
        {"name": "Action","type":"tag"},
        {"name": "Drama","type":"tag"},
        {"name": "Fantasy","type":"tag"},
        {"name": "Horror","type":"tag"},
        {"name": "Shounen","type":"tag"},
        {"name": "Fantasy","type":"tag"},
        {"name": "Military","type":"tag"},
        {"name": "War","type":"tag"},
        {"name": "Based on a Manga","type":"tag"},
        {"name": "Attack on Titan","type":"related"},
        {"name": "Attack on Titan 2nd Season","type":"related"},
        {"name": "Attack on Titan 3rd Season","type":"related"},
        {"name": "Attack on Titan 3rd Season Part II","type":"related"},
        {"name": "Attack on Titan The final Season","type":"related"}
        ]
    
        var color = {
            "0": "#FF60D2",
            "1": "#6E60FF",
            "2": "#850606",
            "3": "#60C7FF",
            "4": "#8ADF45",

            "5": "#FFA69D",
            "6": "#FF6060",
            "7": "#9060FF",
            "8": "#4CD7DD",
            "9": "#FF4040",

            "10": "#D9742F",
            "11": "#2F75F8",
            "12": "#2FF8A1",
            "13": "#2F55F8",
            "14": "#9D2FF8",
            "15": "#DEDE45"
        };
        const svg1 = d3.select(".chart");
        const defs = svg.append("defs"); 
        for(var i=0;i<10;i++){
        var linearGradient = defs 
        .append("linearGradient")
        .attr("id", "gradient"+i)
        .attr("x1","0%")
		.attr("y1","0%")
		.attr("x2","100%")
		.attr("y2","0%");

         linearGradient
        .append("stop")
        .attr("offset", "0%") 
        .attr("stop-color", function(d) { return color[Math.floor(Math.random() * 16)]; })
        linearGradient
        .append("stop")
        .attr("offset", "100%")
        .attr("stop-color", function(d) { return color[Math.floor(Math.random() * 16)]; });
        }

            function dragStarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
                PosX = d.x
                PosY = d.y
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragEnded(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = undefined;
                d.fy = undefined;
            }
            
 

        const drag = d3.drag()
            .on('start', dragStarted)
            .on('drag', dragged)
            .on('end', dragEnded);

            
        const renderInit = function () {


            lines = svg.selectAll('path').data(links).join('line')
                .attr('stroke', '#00BEDB')
                .attr('stroke-width', '1px')
                .attr('opacity', 0.7)

            elementGroup = svg.selectAll(".elementGroup").data(nodes).join('g')
            
            var ur = '#gradient1'
            circles = elementGroup.append('circle')
            .attr("r", function(d) { if(d.type == 'main')return 15+20; else if(d.type == 'related') return 15+8; else return 5;})
            .style("fill", d=> {return "url(#gradient" + Math.floor(Math.random() * 10) + ")"})
         //   .style("fill", function(d) { return color[Math.floor(Math.random() * 16)]; })
            .style("opacity",function(d) { if(d.type == 'main')return 1; else if(d.type == 'related') return 1; else return 0})
        
            circles.call(drag)
                
            text = svg.selectAll(".textGroup").data(nodes).enter()
                .append('text')
                .attr('class', 'text1')
                .attr('font-size', function(d) { if(d.type == 'main')return '0.7em'; else if(d.type == 'related') return '0.4em'; else return '0.5em'})
                .attr('text-anchor', 'middle') 
                .text(d=>d.name)
                .style('opacity',function(d) { if(d.type == 'main')return 1; else if(d.type == 'related') return 0.7; else return 1})
                .attr('fill',function(d) { if(d.type == 'tag') return color[Math.floor(Math.random() * 16)] ; else return 'white'})
                .call(drag)
                
                

        }

        let ticked = function () {
            lines.attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            circles.attr('cx', d => d.x)
                .attr('cy', d => d.y)

                text.attr('x', d => d.x)
                    .attr('y', d => d.y)
        }


    //    d3.then(data => {
       //     nodes = data.nodes;
            links = [];
            for (var i = 0; i <= nodes.length-2; i++)
            links.push({"source": 0, "target": 1+i});


            renderInit();

            simulation = d3.forceSimulation(nodes)
                .force('manyBody', d3.forceManyBody())
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force("link", d3.forceLink(links).strength(1).distance(80))
                .force("collision", d3.forceCollide().radius(30))
                .on('tick', ticked)


       // })
    </script>
</body>

</html>